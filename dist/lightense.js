/*! lightense-images v1.0.10 | Â© Tunghsiao Liu | MIT */
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Lightense"] = factory();
	else
		root["Lightense"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module) => {

eval("function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Lightense = function Lightense() {\n  'use strict'; // Save some bytes\n\n  var w = window;\n  var d = document; // default options\n\n  var defaults = {\n    time: 300,\n    padding: 40,\n    offset: 40,\n    keyboard: true,\n    cubicBezier: 'cubic-bezier(.2, 0, .1, 1)',\n    background: 'var(--bg-color-80, rgba(255, 255, 255, .98))',\n    zIndex: 1000000,\n\n    /* eslint-disable no-undefined */\n    beforeShow: undefined,\n    afterShow: undefined,\n    beforeHide: undefined,\n    afterHide: undefined\n    /* eslint-enable no-undefined  */\n\n  }; // Init user options\n\n  var config = {};\n\n  function invokeCustomHook(methodName) {\n    var method = config[methodName];\n\n    if (!method) {\n      return;\n    }\n\n    if (typeof method !== 'function') {\n      throw \"config.\".concat(methodName, \" must be a function!\");\n    }\n\n    Reflect.apply(method, config, [config]);\n  } // Init target elements\n\n\n  var elements;\n\n  function getElements(elements) {\n    switch (_typeof(elements)) {\n      case 'undefined':\n        throw 'You need to pass an element!';\n\n      case 'string':\n        return d.querySelectorAll(elements);\n\n      case 'object':\n        return elements;\n    }\n  }\n\n  function startTracking(passedElements) {\n    // If passed an array of elements, assign tracking to all\n    var len = passedElements.length;\n\n    if (len) {\n      // Loop and assign\n      for (var i = 0; i < len; i++) {\n        track(passedElements[i]);\n      }\n    } else {\n      track(passedElements);\n    }\n  }\n\n  function track(element) {\n    if (element.src && !element.classList.contains('lightense-target')) {\n      element.classList.add('lightense-target');\n      element.addEventListener('click', function (event) {\n        if (config.keyboard) {\n          // If Command (macOS) or Ctrl (Windows) key pressed, stop processing\n          // and open the image in a new tab\n          if (event.metaKey || event.ctrlKey) {\n            return w.open(element.src, '_blank');\n          }\n        } // Init instance\n\n\n        init(this);\n      }, false);\n    }\n  }\n\n  function insertCss(styleId, styleContent) {\n    var head = d.head || d.getElementsByTagName('head')[0]; // Remove existing instance\n\n    if (d.getElementById(styleId)) {\n      d.getElementById(styleId).remove();\n    } // Create new instance\n\n\n    var styleEl = d.createElement('style');\n    styleEl.id = styleId; // Check if content exists\n\n    if (styleEl.styleSheet) {\n      styleEl.styleSheet.cssText = styleContent;\n    } else {\n      styleEl.appendChild(d.createTextNode(styleContent));\n    }\n\n    head.appendChild(styleEl);\n  }\n\n  function createDefaultCss() {\n    var css = \"\\n:root {\\n  --lightense-z-index: \".concat(config.zIndex - 1, \";\\n  --lightense-backdrop: \").concat(config.background, \";\\n  --lightense-duration: \").concat(config.time, \"ms;\\n  --lightense-timing-func: \").concat(config.cubicBezier, \";\\n}\\n\\n.lightense-backdrop {\\n  box-sizing: border-box;\\n  width: 100%;\\n  height: 100%;\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n  z-index: calc(var(--lightense-z-index) - 1);\\n  padding: 0;\\n  margin: 0;\\n  transition: opacity var(--lightense-duration) ease;\\n  cursor: zoom-out;\\n  opacity: 0;\\n  background-color: var(--lightense-backdrop);\\n  visibility: hidden;\\n}\\n\\n@supports (-webkit-backdrop-filter: blur(30px)) {\\n  .lightense-backdrop {\\n    background-color: var(--lightense-backdrop);\\n    -webkit-backdrop-filter: blur(30px);\\n  }\\n}\\n\\n@supports (backdrop-filter: blur(30px)) {\\n  .lightense-backdrop {\\n    background-color: var(--lightense-backdrop);\\n    backdrop-filter: blur(30px);\\n  }\\n}\\n\\n.lightense-wrap {\\n  position: relative;\\n  transition: transform var(--lightense-duration) var(--lightense-timing-func);\\n  z-index: var(--lightense-z-index);\\n  pointer-events: none;\\n}\\n\\n.lightense-target {\\n  cursor: zoom-in;\\n  transition: transform var(--lightense-duration) var(--lightense-timing-func);\\n  pointer-events: auto;\\n}\\n\\n.lightense-open {\\n  cursor: zoom-out;\\n}\\n\\n.lightense-transitioning {\\n  pointer-events: none;\\n}\");\n    insertCss('lightense-images-css', css);\n  }\n\n  function createBackdrop() {\n    if (d.querySelector('.lightense-backdrop') === null) {\n      config.container = d.createElement('div');\n      config.container.className = 'lightense-backdrop';\n      d.body.appendChild(config.container);\n    } else {\n      config.container = d.querySelector('.lightense-backdrop');\n    }\n  }\n\n  function createTransform(img) {\n    // Get original image size\n    var naturalWidth = img.width;\n    var naturalHeight = img.height; // Calc zoom ratio\n\n    var scrollTop = w.pageYOffset || d.documentElement.scrollTop || 0;\n    var scrollLeft = w.pageXOffset || d.documentElement.scrollLeft || 0;\n    var targetImage = config.target.getBoundingClientRect();\n    var maxScaleFactor = naturalWidth / targetImage.width;\n    var viewportWidth = w.innerWidth || d.documentElement.clientWidth || 0;\n    var viewportHeight = w.innerHeight || d.documentElement.clientHeight || 0;\n    var viewportPadding = config.target.getAttribute('data-lightense-padding') || config.target.getAttribute('data-padding') || config.padding;\n    var viewportWidthOffset = viewportWidth > viewportPadding ? viewportWidth - viewportPadding : viewportWidth - defaults.padding;\n    var viewportHeightOffset = viewportHeight > viewportPadding ? viewportHeight - viewportPadding : viewportHeight - defaults.padding;\n    var imageRatio = naturalWidth / naturalHeight;\n    var viewportRatio = viewportWidthOffset / viewportHeightOffset;\n\n    if (naturalWidth < viewportWidthOffset && naturalHeight < viewportHeightOffset) {\n      config.scaleFactor = maxScaleFactor;\n    } else if (imageRatio < viewportRatio) {\n      config.scaleFactor = viewportHeightOffset / naturalHeight * maxScaleFactor;\n    } else {\n      config.scaleFactor = viewportWidthOffset / naturalWidth * maxScaleFactor;\n    } // Calc animation\n\n\n    var viewportX = viewportWidth / 2;\n    var viewportY = scrollTop + viewportHeight / 2;\n    var imageCenterX = targetImage.left + scrollLeft + targetImage.width / 2;\n    var imageCenterY = targetImage.top + scrollTop + targetImage.height / 2;\n    config.translateX = Math.round(viewportX - imageCenterX);\n    config.translateY = Math.round(viewportY - imageCenterY);\n  }\n\n  function createViewer() {\n    config.target.classList.add('lightense-open'); // Create wrapper element\n\n    config.wrap = d.createElement('div');\n    config.wrap.className = 'lightense-wrap'; // Apply zoom ratio to target image\n\n    setTimeout(function () {\n      config.target.style.transform = 'scale(' + config.scaleFactor + ')';\n    }, 20); // Apply animation to outer wrapper\n\n    config.target.parentNode.insertBefore(config.wrap, config.target);\n    config.wrap.appendChild(config.target);\n    setTimeout(function () {\n      config.wrap.style.transform = 'translate3d(' + config.translateX + 'px, ' + config.translateY + 'px, 0)';\n    }, 20); // Show backdrop\n\n    var item_options = {\n      cubicBezier: config.target.getAttribute('data-lightense-cubic-bezier') || config.cubicBezier,\n      background: config.target.getAttribute('data-lightense-background') || config.target.getAttribute('data-background') || config.background,\n      zIndex: config.target.getAttribute('data-lightense-z-index') || config.zIndex\n    }; // Create new config for item-specified styles\n\n    var config_computed = _objectSpread(_objectSpread({}, config), item_options);\n\n    var css = \"\\n    :root {\\n      --lightense-z-index: \".concat(config_computed.zIndex - 1, \";\\n      --lightense-backdrop: \").concat(config_computed.background, \";\\n      --lightense-duration: \").concat(config_computed.time, \"ms;\\n      --lightense-timing-func: \").concat(config_computed.cubicBezier, \";\\n    }\");\n    insertCss('lightense-images-css-computed', css);\n    config.container.style.visibility = 'visible';\n    setTimeout(function () {\n      config.container.style.opacity = '1';\n    }, 20);\n  }\n\n  function removeViewer() {\n    invokeCustomHook('beforeHide');\n    unbindEvents();\n    config.target.classList.remove('lightense-open'); // Remove transform styles\n\n    config.wrap.style.transform = '';\n    config.target.style.transform = '';\n    config.target.classList.add('lightense-transitioning'); // Fadeout backdrop\n\n    config.container.style.opacity = ''; // Hide backdrop and remove target element wrapper\n\n    setTimeout(function () {\n      invokeCustomHook('afterHide');\n      config.container.style.visibility = '';\n      config.container.style.backgroundColor = '';\n      config.wrap.parentNode.replaceChild(config.target, config.wrap);\n      config.target.classList.remove('lightense-transitioning');\n    }, config.time);\n  }\n\n  function checkViewer() {\n    var scrollOffset = Math.abs(config.scrollY - w.scrollY);\n\n    if (scrollOffset >= config.offset) {\n      removeViewer();\n    }\n  }\n\n  function once(target, event, handler) {\n    target.addEventListener(event, function fn(args) {\n      Reflect.apply(handler, this, args);\n      target.removeEventListener(event, fn);\n    });\n  }\n\n  function init(element) {\n    config.target = element; // TODO: need refine\n    // If element already openned, close it\n\n    if (config.target.classList.contains('lightense-open')) {\n      return removeViewer();\n    }\n\n    invokeCustomHook('beforeShow'); // Save current window scroll position for later use\n\n    config.scrollY = w.scrollY;\n    once(config.target, 'transitionend', function () {\n      invokeCustomHook('afterShow');\n    });\n    var img = new Image();\n\n    img.onload = function () {\n      createTransform(this);\n      createViewer();\n      bindEvents();\n    };\n\n    img.src = config.target.src;\n  }\n\n  function bindEvents() {\n    w.addEventListener('keyup', onKeyUp, false);\n    w.addEventListener('scroll', checkViewer, false);\n    config.container.addEventListener('click', removeViewer, false);\n  }\n\n  function unbindEvents() {\n    w.removeEventListener('keyup', onKeyUp, false);\n    w.removeEventListener('scroll', checkViewer, false);\n    config.container.removeEventListener('click', removeViewer, false);\n  } // Exit on excape (esc) key pressed\n\n\n  function onKeyUp(event) {\n    event.preventDefault();\n\n    if (event.keyCode === 27) {\n      removeViewer();\n    }\n  }\n\n  function main(target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Parse elements\n    elements = getElements(target); // Parse user options\n\n    config = _objectSpread(_objectSpread({}, defaults), options); // Prepare stylesheets\n\n    createDefaultCss(); // Prepare backdrop element\n\n    createBackdrop(); // Pass and prepare elements\n\n    startTracking(elements);\n  }\n\n  return main;\n};\n\nvar singleton = Lightense();\nmodule.exports = singleton;\n\n//# sourceURL=webpack://Lightense/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});